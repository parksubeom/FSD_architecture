[배포주소](https://parksubeom.github.io/front_7th_chapter3-3/posts?limit=10&sortOrder=asc)

- `tsconfig.app.json`의 `compilerOptions`에 `"jsx": "react-jsx"` 설정 추가
- React 17+부터 도입된 New JSX Transform을 TypeScript가 인식하지 못해 발생하는 타입 에러 해결
- (`This JSX tag requires the module path 'react/jsx-runtime' to exist` 에러 대응)

## 과제 체크포인트

### 기본과제

#### 목표 : 전역상태관리를 이용한 적절한 분리와 계층에 대한 이해를 통한 FSD 폴더 구조 적용하기
- 전역상태관리를 사용해서 상태를 분리하고 관리하는 방법에 대한 이해
- Context API, Jotai, Zustand 등 상태관리 라이브러리 사용하기
- FSD(Feature-Sliced Design)에 대한 이해
- FSD를 통한 관심사의 분리에 대한 이해
- 단일책임과 역할이란 무엇인가?
- 관심사를 하나만 가지고 있는가?
- 어디에 무엇을 넣어야 하는가?

#### 체크포인트
- [x] 전역상태관리를 사용해서 상태를 분리하고 관리했나요?
- [x] Props Drilling을 최소화했나요?
- [x] shared 공통 컴포넌트를 분리했나요?
- [x] shared 공통 로직을 분리했나요?
- [x] entities를 중심으로 type을 정의하고 model을 분리했나요?
- [x] entities를 중심으로 ui를 분리했나요?
- [x] entities를 중심으로 api를 분리했나요?
- [x] feature를 중심으로 사용자행동(이벤트 처리)를 분리했나요?
- [x] feature를 중심으로 ui를 분리했나요?
- [x] feature를 중심으로 api를 분리했나요?
- [x] widget을 중심으로 데이터를 재사용가능한 형태로 분리했나요?


### 심화과제

#### 목표: 서버상태관리 도구인 TanstackQuery를 이용하여 비동기코드를 선언적인 함수형 프로그래밍으로 작성하기 

- TanstackQuery의 사용법에 대한 이해
- TanstackQuery를 이용한 비동기 코드 작성에 대한 이해
- 비동기 코드를 선언적인 함수형 프로그래밍으로 작성하는 방법에 대한 이해

#### 체크포인트

- [x] 모든 API 호출이 TanStack Query의 useQuery와 useMutation으로 대체되었는가?
- [x] 쿼리 키가 적절히 설정되었는가?
- [x] fetch와 useState가 아닌 선언적인 함수형 프로그래밍이 적절히 적용되었는가?
- [x] 캐싱과 리프레시 전략이 올바르게 구현되었는가?
- [x] 낙관적인 업데이트가 적용되었는가?
- [x] 에러 핸들링이 적절히 구현되었는가?
- [x] 서버 상태와 클라이언트 상태가 명확히 분리되었는가?
- [x] 코드가 간결하고 유지보수가 용이한 구조로 작성되었는가?
- [x] TanStack Query의 Devtools가 정상적으로 작동하는가?


### 최종과제
- [x] 폴더구조와 나의 멘탈모데일이 일치하나요?
- [x] 다른 사람이 봐도 이해하기 쉬운 구조인가요?

## 과제 셀프회고

### 이번 과제를 통해 이전에 비해 새롭게 알게 된 점이 있다면 적어주세요.
<p><strong>FSD 구조:</strong></p>
<pre><code>📦src
 ┣ 📂app
 ┃ ┣ 📂providers
 ┃ ┃ ┗ 📜QueryProvider.tsx
 ┃ ┣ 📂routers
 ┃ ┃ ┗ 📜App.tsx
 ┃ ┗ 📂styles
 ┃ ┃ ┗ 📜index.css
 ┣ 📂entities
 ┃ ┣ 📂comment
 ┃ ┃ ┗ 📂model
 ┃ ┃ ┃ ┗ 📜types.ts
 ┃ ┣ 📂post
 ┃ ┃ ┣ 📂api
 ┃ ┃ ┃ ┗ 📜index.ts
 ┃ ┃ ┣ 📂model
 ┃ ┃ ┃ ┗ 📜types.ts
 ┃ ┃ ┗ 📂ui
 ┃ ┗ 📂user
 ┃ ┃ ┣ 📂api
 ┃ ┃ ┃ ┗ 📜index.ts
 ┃ ┃ ┣ 📂model
 ┃ ┃ ┃ ┣ 📜types.ts
 ┃ ┃ ┃ ┣ 📜useCurrentUser.ts
 ┃ ┃ ┃ ┗ 📜useUser.ts
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┗ 📜UserProfileModal.tsx
 ┣ 📂features
 ┃ ┣ 📂manage-comment
 ┃ ┃ ┣ 📂api
 ┃ ┃ ┃ ┗ 📜index.ts
 ┃ ┃ ┣ 📂model
 ┃ ┃ ┃ ┗ 📜useCommentMutations.ts
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┣ 📜CommentAddDialog.tsx
 ┃ ┃ ┃ ┗ 📜CommentEditDialog.tsx
 ┃ ┣ 📂manage-post
 ┃ ┃ ┣ 📂api
 ┃ ┃ ┃ ┗ 📜index.ts
 ┃ ┃ ┣ 📂model
 ┃ ┃ ┃ ┗ 📜usePostMutations.ts
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┣ 📜PostAddDialog.tsx
 ┃ ┃ ┃ ┗ 📜PostEditDialog.tsx
 ┃ ┗ 📂post-list
 ┃ ┃ ┣ 📂model
 ┃ ┃ ┃ ┣ 📜store.ts
 ┃ ┃ ┃ ┗ 📜usePostListQuery.ts.ts
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┣ 📜PostDetailDialog.tsx
 ┃ ┃ ┃ ┣ 📜PostFilterBar.tsx
 ┃ ┃ ┃ ┗ 📜PostPagination.tsx
 ┣ 📂pages
 ┃ ┣ 📂dashboard
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┗ 📜DashboardPage.tsx
 ┃ ┣ 📂posts-manager
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┗ 📜Page.tsx
 ┃ ┗ 📂settings
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┗ 📜SettingsPage.tsx
 ┣ 📂shared
 ┃ ┣ 📂assets
 ┃ ┃ ┗ 📜react.svg
 ┃ ┣ 📂config
 ┃ ┣ 📂lib
 ┃ ┃ ┗ 📜highlight.tsx
 ┃ ┗ 📂ui
 ┃ ┃ ┣ 📜Button.tsx
 ┃ ┃ ┣ 📜Card.tsx
 ┃ ┃ ┣ 📜Dialog.tsx
 ┃ ┃ ┣ 📜index.ts
 ┃ ┃ ┣ 📜Input.tsx
 ┃ ┃ ┣ 📜Select.tsx
 ┃ ┃ ┣ 📜Table.tsx
 ┃ ┃ ┗ 📜Textarea.tsx
 ┣ 📂widgets
 ┃ ┣ 📂Footer
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┗ 📜index.tsx
 ┃ ┣ 📂Header
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┗ 📜index.tsx
 ┃ ┗ 📂PostManager
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┣ 📜index.tsx
 ┃ ┃ ┃ ┣ 📜PostDetailDialog.tsx
 ┃ ┃ ┃ ┗ 📜PostTable.tsx
 ┣ 📜index.tsx
 ┗ 📜main.tsx
</code></pre>
<p>이 구조는 "나는 게시판입니다!"라고 소리칩니다.</p>
<ul>
<li>상품이 있구나</li>
<li>장바구니가 있구나</li>
<li>쿠폰을 적용할 수 있구나</li>
<li>결제 기능이 있구나</li>
</ul>
<p><strong>폴더 이름만 봐도 기획서의 목차가 보입니다.</strong></p>
<p>FSD는 기술 스택이 아닌 비즈니스 도메인이 앞으로 나옵니다.</p>

### 본인이 과제를 하면서 가장 애쓰려고 노력했던 부분은 무엇인가요?

생소한 개념을 이해하기위해 리얼월드의 예시로 추상화하여 이해하려고 노력했습니다.
FSD를 이해하기 위한 스타크래프트를 예시

#### Entities (엔티티) = 마린 그 자체 (유닛 정보)

게임 화면에 서 있는 마린 한 기가 있습니다. 아무 명령도 안 내리면 그냥 가만히 서 있습니다.

**설명:** 마린은 스스로 공격하거나 움직일 수 없습니다(액션 없이는). 그저 자신의 스펙(Data)을 가지고 있을 뿐입니다.

**포함된 정보:**
- `HP`: 40
- `공격력`: 6
- `사거리`: 5
- `이미지`: 총을 들고 있는 파란색 해병

**코드 비유:**
```typescript
interface Marine { 
  hp: number; 
  damage: number; 
}

<MarineUnitModel /> // 그저 화면에 마린을 그려주는 컴포넌트
```

**결론:** 엔티티는 "마린은 체력이 40이고 총을 쏜다"라는 **정보** 입니다.

---

#### Features (피처) = 스팀팩 & 어택땅 (명령/기술)

마린을 움직이게 하거나 강해지게 만드는 기술들입니다.

**설명:** 플레이어가 키보드나 마우스를 눌러서 마린의 상태를 바꾸는 행동입니다.

**예시:**
- **스팀팩:** 버튼을 누르면 → 마린의 HP가 10 깎이고(상태 변경) → 공격 속도가 빨라집니다(로직)
- **어택 땅:** 땅을 찍으면 → 해당 좌표로 이동하면서 적을 찾습니다

**코드 비유:**
```typescript
useStimpack() // HP를 깎고 버프를 거는 훅
<StimpackButton /> // 누르면 스팀팩이 발동되는 버튼
```

**결론:** 피처는 엔티티(마린)를 조작해서 변화를 만드는 **동작** 입니다.

---

#### Widgets (위젯) = 하단 UI (인터페이스)

게임 화면 아래쪽에 있는 인터페이스 창입니다.
<img width="696" height="153" alt="image" src="https://github.com/user-attachments/assets/3d256d4f-48d6-4f72-ac34-e4c4cc266c9f" />
**설명:** 이 UI 하나에 모든 것이 다 들어있습니다.

- **<span style="color: #008000">초록색 박스</span>:** 마린의 초상화와 체력바 (Entity를 보여줌)
  - 이곳은 데이터를 보여주기만 할 뿐, 클릭해도 아무 일도 일어나지 않습니다.

- **<span style="color: #FFDCE0">빨간색 박스</span>:** 스팀팩 버튼, 공격 버튼, 홀드 버튼 (Feature들을 배치함)
  - 모두 액션을 유발하는 트리거 버튼들입니다.
  - 사용자가 마우스로 클릭(Action)해서 유닛에게 명령을 내리고 상태를 변화시키는 기능들입니다.

- **<span style="color: #0000FF">파란색 박스</span>:** 미니맵 (Entity)
  - 단순히 맵을 보여주기만 한다면 → Entity (범용 도구)
  - 하지만 미니맵을 통해 이동이나 어택땅이 가능하다면? 액션이 붙은거니까 → Entity + Feature 이므로 Widget으로 볼 수 있습니다.

**특징:** 이 UI 창(Widget)은 마린을 클릭하든, 탱크를 클릭하든 항상 그 자리에 있는 독립적인 틀입니다. 유닛에 따라 내용물만 갈아 끼웁니다.

**코드 비유:**
```typescript
<UnitControlPanel /> // 유닛 정보와 명령 버튼들을 조합해서 만든 하단 UI 바
```

**결론:** 위젯은 엔티티(정보)와 피처(버튼)를 예쁘게 배치해서 플레이어가 게임을 할 수 있게 만든 **조종석** 입니다.

---

#### FSD 레이어 비교표

| 스타크래프트 | FSD 레이어 | 역할 | 특징 |
|-------------|-----------|------|------|
| 마린 유닛 정보 (HP, 공격력) | **Entities** | 데이터 모델 | 스스로 변하지 않음, 정보만 가짐 |
| 스팀팩, 어택땅 | **Features** | 사용자 행동 | 엔티티를 조작해서 변화를 만듦 |
| 하단 UI 패널 | **Widgets** | UI 조립 | 엔티티 + 피처를 배치한 완성된 인터페이스 |
| 미니맵 | **SubWidgets** | 범용 도구 | 게임 전체에서 재사용 가능한 요소, 위치 정보를 가짐 |

---
**TanStack Query** 도 아래와 같이 예시로 추상화하여 이해했습니다. 이해와 더불어 이러한 비유를 통한 이해는 타인에게 나의 완전히 자리 잡히지 않은 지식을 보다 더 직관적이고 간단하게 설명할 수 있어서 좋았습니다.
<img width="592" height="461" alt="image" src="https://github.com/user-attachments/assets/0fa6b0ba-9cde-49e4-ab1e-40cd4fc6c104" />

### 헷갈리는 포인트 정리 (Q&A)

#### Q1. `Shared/ui/Button`과 `Entities/User/ui/UserCard`의 차이는?

- **`Shared`의 버튼:** "파란색 버튼"일 뿐입니다. 안에 '로그인'이 들어갈지 '삭제'가 들어갈지 모릅니다.
  - 도메인 지식이 전혀 없는 범용 컴포넌트
  - 투두 리스트 앱에도, 쇼핑몰에도 그대로 사용 가능

- **`Entities`의 유저 카드:** "유저 데이터"를 보여주기 위해 특화되어 있습니다.
  - 유저라는 도메인 개념을 알고 있음
  - 다른 프로젝트(예: 쇼핑몰 상품 카드)에는 그대로 쓸 수 없습니다

**핵심 차이:** 도메인 지식의 유무

---

#### Q2. `Entities`의 API와 `Features`의 API 호출의 차이는?

- **Entities:** `fetchUser(id)` 처럼 단순히 데이터를 가져오는 함수 그 자체입니다.
```typescript
  // entities/user/api/fetchUser.ts
  export const fetchUser = async (id: string) => {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  };
```
  - 순수하게 데이터만 조회
  - 부수 효과 없음

- **Features:** `const handleLogin = async () => { ... }` 처럼 데이터를 가져온 후 검증하고, 리다이렉트하고, 토스트 메시지를 띄우는 일련의 과정을 포함합니다.
```typescript
  // features/auth/model/useLogin.ts
  const handleLogin = async (credentials) => {
    const user = await fetchUser(credentials); // Entity API 사용
    if (!user.isVerified) {
      showToast("이메일 인증이 필요합니다");
      return;
    }
    saveToken(user.token);
    navigate("/dashboard");
  };
```
  - 비즈니스 로직 포함
  - 여러 액션을 조합

**핵심 차이:** 단순 조회 vs 비즈니스 워크플로우

---

#### Q3. `PostListTable`은 왜 `Widgets`이여야 할까?

테이블 안에는 여러 레이어의 요소들이 섞여 있습니다:
- **`Post` 데이터** (Entity) → 게시글 정보 표시
- **`DeleteButton`** (Feature) → 삭제 기능
- **`TagFilter`** (Feature) → 태그 필터링 기능
- **`UserAvatar`** (Entity) → 작성자 정보 표시

이렇게 서로 다른 레이어의 요소들을 묶어서 하나의 큰 기능을 하는 덩어리가 되었기 때문에 **Widget** 입니다.

**Widget의 역할:**
- 직접 그리기보다는 조립하기
- Entity의 UI와 Feature의 액션을 배치
- 완성된 사용자 경험 제공

---

#### Q4. 상태 관리는 어디에?

상태의 성격에 따라 레이어가 달라집니다:

**Entity 레이어:**
```typescript
// entities/user/model/useUserStore.ts
const useUserStore = create((set) => ({
  currentUser: null,
  setUser: (user) => set({ currentUser: user }),
}));
```
- **특징:** 내 정보 저장 - 여러 곳에서 읽기 전용으로 많이 쓰임
- **예시:** 로그인한 유저 정보, 프로필 데이터
- **언제:** 앱 전역에서 "있는 그대로" 참조만 하는 데이터

**Feature 레이어:**
```typescript
// features/post-filter/model/usePostFilterStore.ts
const usePostFilterStore = create((set) => ({
  searchQuery: "",
  selectedTags: [],
  sortBy: "date",
  setSearchQuery: (query) => set({ searchQuery: query }),
}));
```
- **특징:** 검색어, 필터 상태 - 특정 기능 동작을 위해 필요함
- **예시:** 검색 조건, 정렬 옵션, 페이지네이션 상태
- **언제:** 사용자의 "행동"에 따라 계속 변하는 UI 상태

**핵심 차이:**
- Entity Store = "누가 로그인했는가?" (정체성)
- Feature Store = "무엇을 검색하고 있는가?" (행동)


### 아직은 막연하다거나 더 고민이 필요한 부분을 적어주세요.

### 이번에 배운 내용 중을 통해 앞으로 개발에 어떻게 적용해보고 싶은지 적어주세요.


## 챕터 셀프회고

| 기존 코드 요소 | 분석 (역할) | FSD 배치 (Target) | 이유 (Why?) |
|---------------|-------------|-------------------|-------------|
| **Data Types** | `Post`, `User`, `Comment`, `Tag` 데이터 구조 | Entities (`model/types.ts`) | 데이터의 정의는 비즈니스 로직의 기초이자 변하지 않는 명사이므로. |
| **API Calls** | `fetch('/api/posts...')`, `fetch('/api/users...')` | Entities (`api/*.ts`) | 단순 데이터 조회는 Entity, 복잡한 로직은 Feature로 분리. |
| **Global State** | `posts`, `limit`, `skip`, `searchQuery` 등 목록 상태 | Features (`post-list/model`) | 여러 컴포넌트(필터바, 테이블, 페이지네이션)가 공유해야 하는 상태이므로 전역 스토어(Zustand)로 관리. |
| **Actions** | `addPost`, `updatePost`, `deletePost` | Features (`manage-post/model`) | 데이터를 변경하는 '행동(Action)'이므로 Feature. |
| **Sub UI** | `highlightText` 함수 | Shared (`lib/highlight.ts`) | 도메인(Post)과 상관없이 문자열을 꾸며주는 순수 유틸리티이므로. |
| **Complex UI** | `renderPostTable` (테이블 렌더링) | Widgets (`PostListTable`) | Post, User, Action 버튼들이 조립된 완성된 형태의 UI이므로. |
| **Modal UI** | `showUserModal` (유저 상세) | Entities (`user/ui`) | 유저 정보를 '보여주기만' 하는 UI이므로 Entity. |
| **Filter UI** | 검색창, 태그 선택, 정렬 선택 | Features (`post-filter/ui`) | 리스트 상태를 변경하는 조작 도구이므로. |
---

### 클린코드: 읽기 좋고 유지보수하기 좋은 코드 만들기

> 코드를 작성하는 시간보다 읽는 시간이 훨씬 길다는 사실을 몸소 체험하며, '읽기 좋은 코드'가 갖는 비즈니스적 가치와 지속 가능한 아키텍처에 대해 깊게 고민해본 시간이었습니다.

#### 1. 더티 코드와의 조우: "어디서 터질지 모르는 시한폭탄"

처음 복잡하게 얽힌 코드를 마주했을 때의 감정은 막막함을 넘어선 **두려움** 이었습니다.
함수 하나가 수백 줄에 달하고, 변수명은 `data`, `temp` 처럼 의미를 알 수 없는 단어들로 가득했습니다.

가장 큰 문제는 **'어떻게(How)'** 만 있고 **'무엇을(What)'** 이 없는 코드였다는 점입니다.
`style={{ background: role === 'admin' ? 'red' : 'blue' }}` 처럼 구현 상세가 그대로 노출되어 있다 보니, 코드 한 줄을 수정했을 때 전혀 상관없어 보이는 다른 기능이 망가질 것 같은 불안감이 항상 있었습니다. 마치 언제 터질지 모르는 시한폭탄을 안고 개발하는 기분이었습니다.

---

#### 2. 관점의 전환: 선언적인 코드와 동료에 대한 배려

리팩토링을 진행하며 깨달은 클린 코드의 본질은 **'동료에 대한 배려'** 이자 **'문서로서의 코드'** 였습니다.

기존에는 기계가 실행할 로직을 나열하는 데 급급했다면, 이번엔 **"무엇을 의도하는가"** 를 중심으로 코드를 재구성했습니다.

* **구현 숨기기:** 복잡한 조건문을 `isAdmin`이나 `canDeletePost` 같은 명확한 변수명 뒤로 숨겼습니다.
* **의도 드러내기:** `<div onClick={...}>` 대신 `<ActionButton type="delete" />`와 같이 컴포넌트 이름만 보고도 역할을 알 수 있게 추상화했습니다.

그러자 코드가 문서처럼 읽히기 시작했습니다. 동료(혹은 미래의 나)가 내부 구현을 다 뜯어보지 않아도, "아, 이건 삭제 버튼이구나" 하고 믿고 사용할 수 있는 **선언적인 구조** 가 되었습니다.

---


#### 3. 정리: 난장판인 창고를 요리사의 팬트리로

이번 클린 코드 작업을 비유하자면, **"물건이 뒤죽박죽 쌓인 창고를, 셰프가 요리에만 집중할 수 있는 잘 정돈된 팬트리로 바꾸는 과정"** 이었습니다.

* **UI와 도메인의 분리:** 셰프(Domain Logic)는 레시피에 집중하고, 재료 손질(UI Logic)은 보조가 미리 해두는 것처럼 역할을 명확히 나누었습니다.
* **지속 가능한 아키텍처:** 창고가 정리되니(구조화), 어떤 주문(요구사항 변경)이 들어와도 당황하지 않고 필요한 재료를 바로 꺼내 대응할 수 있게 되었습니다.

결국 유지보수하기 쉬운 코드란, **개발자가 시스템에 끌려다니는 것이 아니라 주도권을 쥐고 통제할 수 있는 코드** 라는 것을 배웠습니다. 앞으로도 '돌아가는 코드'에 안주하지 않고 '읽히는 코드'를 지향하는 개발자가 되고싶습니다.

---

### 결합도 낮추기: 디자인 패턴, 순수함수, 컴포넌트 분리, 전역상태 관리

> 모든 것이 한 덩어리로 뭉쳐있던 '모놀리식' 컴포넌트를 분해하며, 유연한 소프트웨어란 무엇인지, 그리고 좋은 설계가 개발자에게 어떤 자유를 주는지 깊게 깨닫는 과정이었습니다.

#### 1. 거대한 단일 컴포넌트: "건드리면 무너지는 젠가 게임"

처음 마주했던 페이지 컴포넌트는 모든 로직과 UI가 한곳에 뒤섞인 거대한 덩어리였습니다. 테이블 렌더링, 필터링 로직, 데이터 호출, 모달 제어까지 수백 줄의 코드가 서로를 강하게 의존하고 있었습니다.

가장 큰 문제는 **'강한 결합도'** 였습니다.
기능 하나를 수정하려고 하면 연결된 다른 기능이 망가질까 봐 노심초사해야 했고, 코드를 건드리는 것이 마치 **언제 무너질지 모르는 젠가 게임 블록을 빼내는 것** 처럼 느껴졌습니다. 이대로는 기능 추가는커녕 유지보수조차 어려웠습니다.
실무였다면 "괜히 이걸 내가 건드려서 잘못되면 내가 다 뒤집어 쓰는거 아니야?" 라는 두려움 때문에 애써 못본척 "돌아가니까 됐지!" 하고 넘어갔을 것 같습니다.

---

#### 2. 순수 함수의 발견: "리액트를 몰라도 동작하는 로직"

이 문제를 해결하기 위해 가장 먼저 시도한 것은 **'로직의 격리'** 였습니다. 

* **Before:** 컴포넌트 내부에서 `state`와 섞여있어 테스트하기 어렵고 재사용이 불가능했습니다.
* **After:** 외부 의존성이 전혀 없는 **순수 함수** 로 만들자, 이 함수는 리액트 컴포넌트가 없어도 당장 쓸 수 있는 코드가 되었습니다.

**"이건 무조건 순수함수구나!"** 하는 깨달음과 함께, 비즈니스 로직을 UI에서 분리해내는 것이 결합도를 낮추는 첫걸음임을 확신하게 되었습니다.

---

#### 3. 책임의 분리와 전역 상태

다음 단계는 컴포넌트 간의 복잡한 데이터 전달 구조를 개선하는 것이었습니다. 기존에는 상위 컴포넌트가 모든 데이터를 쥐고 하위 컴포넌트에게 일일이 내려주는 **'Props Drilling'** 이 심각했습니다.

이를 해결하기 위해 **역할** 을 명확히 나누었습니다.

* **테이블 컴포넌트:** 데이터를 어떻게 가져오는지 몰라도 됩니다. 오직 **'데이터를 보여주는 역할'** 에만 집중하도록 만들었습니다.
* **전역 상태 관리:** 복잡한 데이터 흐름은 `Zustand에 위임하여, 컴포넌트들이 서로를 의존하지 않고 필요한 데이터만 **'구독'** 하도록 변경했습니다.

컴포넌트들이 서로 결합도가 낮아지자, 코드는 이전에 비해 많이 단순해졌습니다. 서로 영향을 주지 않으면서 각자의 역할만 수행하는 **'느슨한 결합'** 의 상태가 되었습니다.

---

#### 4. 정리: 위태로운 젠가 탑을 견고한 레고 성으로

이번 결합도 낮추기 작업을 비유하자면, **"하나만 건드려도 휘청거리던 젠가 탑을, 언제든 조립하고 교체할 수 있는 레고 블록으로 바꾸는 과정"** 이었습니다.

* **유연한 구조:** 이제 테이블 컴포넌트를 대시보드에 쓰든, 관리자 페이지에 쓰든 상관없습니다. 레고 블록처럼 끼워 맞추기만 하면 됩니다.
* **확장성:** 기능을 추가하거나 변경할 때, 전체를 무너뜨릴 걱정 없이 해당 블록(컴포넌트/로직)만 수정하면 됩니다.

결국 결합도를 낮춘다는 것은, **변화에 유연하게 대응할 수 있는 힘을 기르는 것** 임을 배웠습니다. 영원히 바뀌지 않는 코드는 없고, 기획 또한 언제든 상황에 맞게 변경될 수 있습니다. 예전에는 올바른 방법이였던게, 지금에서는 틀린 방법일 수 있듯이 변화에 유연한 코드의 중요성을 다시한번 상기시키는 챕터였습니다.

---

### 응집도 높이기: 서버상태관리, 폴더 구조

> "이 코드는 대체 어디에 둬야 하지?"라는 고민이 사라지자, 개발의 속도와 질이 동시에 올라갔습니다.

#### 1. 낮은 응집도의 혼란: "파일 탐색기 속의 보물찾기"

프로젝트 초반에는 기능 하나를 수정하려면 파일 탐색기를 위아래로 훑으며 관련 코드를 찾아 헤매야 했습니다

서로 밀접하게 연관된 코드들이 물리적으로 멀리 떨어져 있다 보니(낮은 응집도), 수정할 때마다 **'맥락'** 을 잃어버리기 일쑤였고, 단순한 기능 추가조차 시작도 전에 지쳐버리는 비효율의 연속이었습니다.

---

#### 2. FSD와 Screaming Architecture: "폴더 구조가 곧 기획서"

이 문제를 해결하기 위해 도입한 FSD 아키텍처는 확실한 장점이 있었습니다. 핵심은 **'비즈니스 도메인 기준의 응집'** 이었습니다.

* **Before:** 기술 스택 기준(`components`, `hooks`)으로 나뉘어 있어, 폴더만 봐선 무슨 앱인지 알 수 없었습니다..
* **After:** 기능 기준(`features/post-list`, `entities/post`)으로 모아두니, 폴더 구조만 봐도 **"아, 이건 게시판이구나!"** 하고 알 수 있는 **'Screaming Architecture'** 가 되었습니다.

사용자 데이터는 `Entities`에, 검색 기능은 `Features`에 두는 명확한 기준이 생기자, 마치 다이소처럼 **"아 이 브러시는 저기 화장품과 관련된 용품 및 소비재쪽에 진열해야겠다"**  처럼 본능적으로 코드가 있어야 할 위치를 짐작할 수 있었습니다.
<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/2746a50e-200b-410f-9ec2-f36d960649ca" />
↓
↓
<img width="600" height="400" alt="image" src="https://github.com/user-attachments/assets/56d7c72d-90ba-4850-bfbe-94259707a4d6" />


---

#### 3. 서버 상태의 분리: "데이터 가져오기는 도구에게, 활용은 나에게"

응집도를 높이는 또 다른 열쇠는 **'서버 상태(Server State)'** 와 **'클라이언트 상태(Client State)'** 의 분리였습니다.

기존에는 `useEffect` 안에서 데이터를 가져오고, 로딩(`isLoading`)과 에러(`isError`) 상태를 직접 관리하느라 컴포넌트 코드가 비대했습니다. 하지만 **TanStack Query** 를 도입하면서 이러한 귀찮은 과정을 생략할 수 있었습니다.

* **도구의 역할:** 데이터 패칭, 캐싱, 동기화 같은 복잡한 기술적 문제는 도구에게 위임했습니다.
* **나의 역할:** 도구가 건네준 데이터를 **'어떻게 화면에 보여줄지'** 에만 온전히 집중할 수 있게 되었습니다.

덕분에 컴포넌트는 지저분한 비동기 로직을 털어내고, 본연의 역할인 UI 렌더링에만 집중하는 **높은 응집도** 를 갖추게 되었습니다.

---

#### 4. 정리: 동네슈퍼에서 다이소로

* **위치 찾기:** FSD 구조 덕분에 코드가 있어야 할 '좌표'가 명확해졌습니다.
* **집중하기:** 서버 상태 분리 덕분에 Boilerplate가 줄어들고 사라지고 핵심 로직만 남았습니다.

결국 응집도를 높인다는 것은, 흩어진 퍼즐 조각을 맞춰 **하나의 완성된 그림(기능)으로 묶어두는 것** 이었습니다. 혼란스러웠던 개발 과정이 체계적인 질서를 갖추게 된 값진 경험이었습니다.



## 리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문

### 1. 서버 상태 관리 및 캐싱 (TanStack Query 관련)
**배경:** DummyJSON을 사용하다 보니 서버에 데이터가 저장되지 않아, invalidateQueries 대신 setQueriesData로 강제로 캐시를 수정해서 화면을 갱신하는 작업을 했습니다.

- **Q1.** 낙관적 업데이트(Optimistic Updates)의 실패 처리는 실무에서 얼마나 정교하게 구현하나요? 이번엔 가짜 API라 setQueriesData로 화면을 강제로 바꿨는데, 실제 서버 환경에서는 '낙관적 업데이트'를 적용할 것 같습니다. 만약 서버 요청이 실패해서 롤백해야 할 때, 사용자 경험을 해치지 않으면서 자연스럽게 처리하는 멘토님만의 팁이 있을까요?

- **Q2.** 서버 상태와 클라이언트 상태(Zustand)의 명확한 구분 기준은 무엇인가요? 필터링이나 검색어 같은 상태는 URL 쿼리 파라미터로 관리하거나 전역 스토어(Zustand)에 뒀고, 데이터는 React Query로 관리했습니다. 하지만 때로는 이 경계가 모호할 때가 있었습니다. (예: 모달의 열림/닫힘 상태가 특정 데이터에 종속될 때). 실무에서는 이 두 상태의 동기화를 어떻게 처리하시나요?

### 2. 배포 및 환경 설정
**배경:** 로컬에서는 Vite Proxy로 /api를 썼지만, 배포 후에는 실제 URL을 써야 해서 vite.config.ts와 API Client 설정에서 애를 먹었습니다. GitHub Pages의 SPA 404 문제도 겪었고요.

- **Q3.** 프론트엔드 배포 시 환경 변수 관리의 Best Practice가 궁금합니다. 로컬(Proxy)과 프로덕션(Real URL) 환경을 분리하기 위해 import.meta.env를 활용해 분기 처리를 했습니다. 실제 상용 서비스에서는 개발, 스테이징, 운영 등 환경이 더 많을 텐데, 빌드 시점과 런타임 시점의 환경 변수 주입을 어떻게 효율적으로 관리하시나요?

- **Q4.** SPA 배포 시 404 처리(Rewrite)를 위한 인프라 구성은 보통 어떻게 하시나요? GitHub Pages에서는 404.html 트릭을 써서 해결했는데, AWS S3 + CloudFront나 Vercel 같은 환경에서는 어떤 방식으로 라우팅 문제를 해결하는지, 그리고 비용 효율적인 정적 호스팅 구성이 궁금합니다.

### 3. 아키텍처 및 FSD 계층 구분 (Dashboard 구현 관련)
**배경:** 기존 과제 스펙에는 없었지만, 아키텍처의 유연성을 시험해보고자 대시보드 페이지를 추가로 구현했습니다.
대시보드는 '조회'만 필요하지만, 개발 효율성을 위해 기존의 `PostTable`을 재사용했습니다. 이 컴포넌트는 **Widget** 레이어에 위치하며, 내부적으로 CRUD 로직을 포함할 수 있는 구조지만 `props`를 비워둠으로써 대시보드에서는 조회 전용으로 동작하게 만들었습니다.

- **Q5. 위젯(Widget)의 범용성과 최적화 사이의 딜레마**
  "현재 `PostTable`은 CRUD 관련 Feature들과 결합될 수 있는 '무거운 위젯'입니다. 대시보드 같은 단순 조회 화면에서도 **코드 재사용성성** 을 위해 이 위젯을 그대로 사용하는 것이 괜찮은 방법인지 고민됩니다.
  아니면, 비록 코드가 중복되더라도 대시보드용으로 가벼운 `Entity` 레벨의 테이블 컴포넌트를 별도로 분리하는 더 나은방식인지 궁금합니다!"
